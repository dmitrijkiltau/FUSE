# FUSE 1.0.0 Stability Contract

Status: Proposed  
Activation target: `v1.0.0` release tag  
Scope: language/runtime/tooling compatibility contract for the `1.x` line

This document replaces strategy prose with an explicit contract.

## Document contract

- `Normative`: Yes after status is changed to `Accepted`.
- `Front door`: No. Start onboarding from `../README.md`.
- `Owned concerns`: frozen surfaces for `1.x`, allowed evolution, pre-`1.0.0` acceptance gates,
  and change-control requirements.
- `Conflict policy`:
  - syntax/static semantics defer to `fls.md`
  - runtime/boundary semantics defer to `runtime.md`
  - release process and AOT SLO policy defer to `../ops/RELEASE.md` and `../ops/AOT_RELEASE_CONTRACT.md`
  - identity/scope boundaries defer to `../governance/IDENTITY_CHARTER.md` and `../governance/scope.md`

Normative terms in this document:

- `must` / `must not`: required behavior
- `should`: strong recommendation with explicit rationale if not followed
- `may`: allowed implementation latitude

## Contract lifecycle

1. Before `v1.0.0`, this document is a release-candidate contract and may be edited intentionally.
2. At `v1.0.0`, maintainers set `Status: Accepted`; from that point it is normative for all `1.x` releases.
3. Breaking changes to accepted frozen surfaces require `2.0.0`.

## Frozen surfaces for 1.x

The following are frozen once this contract is accepted.

### 1) Language and runtime semantics

1. Grammar, parsing rules, and static semantics in `fls.md`.
2. Boundary/runtime semantics in `runtime.md`, including:
   - validation timing and default application behavior
   - JSON encode/decode behavior
   - config resolution precedence
   - standardized error JSON mapping
   - HTTP status mapping
   - `Option`/`Result` + `?!` behavior
3. Backend semantic authority model:
   - parser/frontend canonicalization define semantics
   - AST/VM/native/AOT are execution strategies
   - backend-specific semantic reinterpretation is a correctness bug

### 2) Runtime operational envelopes

1. AOT fatal envelope shape:
   - `fatal: class=<runtime_fatal|panic> pid=<...> message=<...> <build-info>`
2. AOT build metadata keys:
   - `mode`, `profile`, `target`, `rustc`, `cli`, `runtime_cache`, `contract`

### 3) Dependency and lockfile semantics

1. `fuse.toml` dependency source rules:
   - exactly one source: `path` or `git`
   - git selectors: at most one of `rev`, `tag`, `branch`, `version`
   - `subdir` valid only for git dependencies
2. Resolver conflict policy:
   - transitive conflicts are rejected when the same dependency name resolves from differing specs
3. Lockfile behavior:
   - `fuse.lock` format version remains stable for the `1.x` line unless a major bump is taken
   - lock entries are refreshed only when requested spec fingerprints differ

## Surfaces that may evolve in 1.x

### Stable-additive (backward compatible only)

1. New syntax or runtime capabilities that do not change existing program meaning.
2. Additional diagnostics, linting, and tooling ergonomics that preserve existing behavior.
3. New optional manifest fields and CLI flags that do not alter existing defaults.

### Provisional

1. New observability fields and telemetry details may expand (additive only).
2. Optional editor/LSP capabilities may evolve between minor releases.
3. Provisional surfaces must be labeled as such where introduced.

### Internal (no compatibility guarantee)

1. `fusec` Rust internals, IR details, JIT ABI internals.
2. `.fuse/build/*` cache storage internals (except user-visible contract explicitly frozen above).
3. Internal script implementation details not documented as user-facing contract.

## Required entry criteria before accepting 1.0.0

All criteria below must be complete before maintainers switch this document to `Accepted`.

1. Reference service exists at `examples/reference-service/` with:
   - auth flow
   - CRUD routes
   - validation failure paths
   - DB migrations
   - deterministic `spawn` usage
   - structured logging enabled path
   - OpenAPI enabled route
   - AOT build + deployable artifact validation
   - it is the single canonical package-level service example in this repository
   - legacy canonical package examples are removed after migration
2. Observability baseline exists and is documented:
   - request ID propagation
   - optional structured request logging mode
   - deterministic panic classification
   - metrics hook extension point
3. AOT release-default behavior is implemented:
   - `fuse build --release` produces AOT output by default
   - non-AOT local-dev path remains available and documented
4. Release gates pass on the reference service and repository suites:
   - `./scripts/semantic_suite.sh`
   - `./scripts/authority_parity.sh`
   - `./scripts/lsp_suite.sh`
   - `./scripts/reliability_repeat.sh --iterations 2`
   - `./scripts/check_aot_perf_slo.sh`
   - `./scripts/packaging_verifier_regression.sh`
   - `./scripts/release_smoke.sh`
5. Canonical-example migration is complete:
   - user-facing docs, scripts, gates, and benchmark fixtures reference `examples/reference-service/`
   - no contract/workflow references to removed legacy canonical examples remain
6. Contract-facing documentation is synchronized in the same release window:
   - `README.md`
   - `guides/fuse.md`
   - `spec/fls.md`
   - `spec/runtime.md`
   - `governance/scope.md`
   - `docs/site/specs/reference.md` (regenerated via `./scripts/generate_guide_docs.sh`)

## Change-control rules after acceptance

1. Patch (`1.x.y`) releases must not introduce contract-breaking behavior.
2. Minor (`1.y.0`) releases may add behavior, but existing behavior must remain compatible.
3. Any contract-facing change must include, in the same PR:
   - spec updates (`fls.md` and/or `runtime.md` when semantics change)
   - test coverage updates (parser/sema/runtime/parity as applicable)
   - changelog entry with migration notes when behavior is user-visible
4. Any proposal to relax this contract must include explicit maintainer approval and rationale.

## Explicit non-goals for 1.x

The following remain out of scope for `1.x` unless this contract is revised before acceptance:

1. User-defined generics / traits / interface systems
2. Macro or parser plugin systems
3. Runtime reflection that changes language behavior
4. Backend-specific semantic dialects
5. Plugin extension systems that alter core semantics
