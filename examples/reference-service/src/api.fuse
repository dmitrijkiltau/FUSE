requires db

import { NotFound, Unauthorized, BadRequest, Forbidden } from "./errors"
import { Note, NoteId, NoteCreate, NoteVisibilityUpdate, AuthSession, RegisterInput, LoginInput, RequestContext, request_context_user_id } from "./domain"
import { register_user, login_user, logout_session, session_user_id, session_token } from "./auth"
import { anonymous_context, session_context, authenticated_context, scoped_context, request_context_or_anonymous, request_session_token } from "./context"
import Home from "./ui/pages/home"
import NotesUi from "./ui/components/notes"

fn new_note_id() -> NoteId!BadRequest:
  var seed = ""
  transaction:
    let row = db.one("select lower(hex(randomblob(12))) as id") ?! BadRequest(message="failed to allocate note id")
    seed = row["id"]
  return NoteId(value="note-${seed}")

fn require_request_token() -> String!Unauthorized:
  let token = request_session_token()
  if token == "":
    null ?! Unauthorized(message="missing session cookie")
  return token

fn scoped_request_context(scope: String) -> RequestContext!Unauthorized!Forbidden:
  let token = require_request_token() ?!
  return scoped_context(token, scope) ?!

service ReferenceService at "/":
  # Register a new user account and issue a session token.
  post "/api/auth/register" body RegisterInput -> AuthSession!Unauthorized!BadRequest:
    return register_user(body)

  # Login and issue/refresh a session token.
  post "/api/auth/login" body LoginInput -> AuthSession!Unauthorized!BadRequest:
    return login_user(body)

  # Logout by invalidating the active session token.
  delete "/api/auth/sessions/{token: String}" -> Unit!Unauthorized:
    return logout_session(token)

  # List notes for the authenticated session owner only.
  get "/api/sessions/{token: String}/notes" -> List<Map<String, String>>!Unauthorized!Forbidden:
    let ctx = scoped_context(token, "notes:read") ?!
    var rows: List<Map<String, String>> = []
    transaction:
      rows = db
        .from("notes")
        .select(["id", "title", "content", "is_public"])
        .where("owner_id", "=", request_context_user_id(ctx))
        .order_by("id", "desc")
        .all()
    return rows

  # Get a single note by id for the authenticated session owner only.
  get "/api/sessions/{token: String}/notes/{id: String}" -> Map<String, String>!NotFound!Unauthorized!Forbidden:
    let ctx = scoped_context(token, "notes:read") ?!
    var row = {"id": "", "title": "", "content": "", "is_public": "0"}
    transaction:
      row = db
        .from("notes")
        .select(["id", "title", "content", "is_public"])
        .where("owner_id", "=", request_context_user_id(ctx))
        .where("id", "=", id)
        .one()
        ?! NotFound(message="not found")
    return row

  # Update a note by id for the authenticated session owner only.
  put "/api/sessions/{token: String}/notes/{id: String}" body NoteCreate -> Note!NotFound!Unauthorized!Forbidden!BadRequest:
    let ctx = scoped_context(token, "notes:write") ?!
    var row = {"id": "", "title": "", "content": "", "is_public": "0"}
    transaction:
      db
        .from("notes")
        .select(["id"])
        .where("owner_id", "=", request_context_user_id(ctx))
        .where("id", "=", id)
        .one()
        ?! NotFound(message="not found")
      db.exec(
        "update notes set title = ?, content = ? where id = ? and owner_id = ?",
        [body.title, body.content, id, request_context_user_id(ctx)]
      )
      row = db
        .from("notes")
        .select(["id", "title", "content", "is_public"])
        .where("owner_id", "=", request_context_user_id(ctx))
        .where("id", "=", id)
        .one()
        ?! NotFound(message="not found")
    let published = row["is_public"] == "1"
    return Note(
      id=NoteId(value=row["id"]),
      title=row["title"],
      content=row["content"],
      published=published
    )

  # Create a new note for the authenticated session owner.
  post "/api/sessions/{token: String}/notes" body NoteCreate -> Note!Unauthorized!Forbidden!BadRequest:
    let ctx = scoped_context(token, "notes:write") ?!
    let id = new_note_id() ?!
    transaction:
      db.exec(
        "insert into notes (id, owner_id, title, content, is_public) values (?, ?, ?, ?, '0')",
        [id.value, request_context_user_id(ctx), body.title, body.content]
      )
    return Note(id=id, title=body.title, content=body.content, published=false)

  # Set note visibility for the authenticated session owner.
  put "/api/sessions/{token: String}/notes/{id: String}/visibility" body NoteVisibilityUpdate -> Note!NotFound!Unauthorized!Forbidden!BadRequest:
    let ctx = scoped_context(token, "notes:write") ?!
    var row = {"id": "", "title": "", "content": ""}
    var is_public = "0"
    var published = false
    if body.published == "1":
      is_public = "1"
      published = true
    else: 
      if body.published != "0":
        null ?! BadRequest(message="published must be '1' or '0'")
    transaction:
      row = db
        .from("notes")
        .select(["id", "title", "content"])
        .where("owner_id", "=", request_context_user_id(ctx))
        .where("id", "=", id)
        .one()
        ?! NotFound(message="not found")
      db.exec(
        "update notes set is_public = ? where id = ? and owner_id = ?",
        [is_public, id, request_context_user_id(ctx)]
      )
    return Note(
      id=NoteId(value=row["id"]),
      title=row["title"],
      content=row["content"],
      published=published
    )

  # Delete a note by id for the authenticated session owner.
  delete "/api/sessions/{token: String}/notes/{id: String}" -> Unit!Unauthorized!Forbidden:
    let ctx = scoped_context(token, "notes:write") ?!
    transaction:
      db.exec("delete from notes where id = ? and owner_id = ?", [id, request_context_user_id(ctx)])

  # Leave an idempotent like on a published note (must not be own note).
  post "/api/sessions/{token: String}/public/notes/{id: String}/likes" -> Unit!NotFound!Unauthorized!Forbidden:
    let ctx = scoped_context(token, "notes:read") ?!
    transaction:
      let note = db
        .from("notes")
        .select(["owner_id"])
        .where("is_public", "=", "1")
        .where("id", "=", id)
        .one()
        ?! NotFound(message="not found")
      if note["owner_id"] == request_context_user_id(ctx):
        null ?! Forbidden(message="cannot like your own note")
      db.exec(
        "insert or ignore into note_likes (note_id, user_id) values (?, ?)",
        [id, request_context_user_id(ctx)]
      )

  # List notes that are published and readable without authentication.
  get "/api/public/notes" -> List<Map<String, String>>:
    var rows: List<Map<String, String>> = []
    transaction:
      rows = db.query(
        "select n.id, n.title, n.content, n.owner_id, cast((select count(*) from note_likes l where l.note_id = n.id) as text) as likes from notes n where n.is_public = '1' order by n.id desc"
      )
    return rows

  # Read a single published note without authentication.
  get "/api/public/notes/{id: String}" -> Map<String, String>!NotFound:
    var row = {"id": "", "title": "", "content": "", "owner_id": "", "likes": "0"}
    transaction:
      row = db.one(
        "select n.id, n.title, n.content, n.owner_id, cast((select count(*) from note_likes l where l.note_id = n.id) as text) as likes from notes n where n.is_public = '1' and n.id = ?",
        [id]
      )
        ?! NotFound(message="not found")
    return row

  # Server-rendered UI entry point.
  get "/" -> Html:
    let token = request_session_token()
    let ctx = request_context_or_anonymous()
    if token != "" and request_context_user_id(ctx) == "":
      response.delete_cookie("sid")
    return Home.render_page(ctx)

  # Server-rendered shell for an existing session token.
  get "/sessions/{token: String}" -> Html!Unauthorized:
    let ctx = authenticated_context(token) ?!
    response.cookie("sid", token)
    return Home.render_page(ctx)

  post "/ui/auth/register" body RegisterInput -> Html!Unauthorized:
    let session = register_user(body) ?!
    let token = session_token(session)
    response.cookie("sid", token)
    let ctx = session_context(token, session_user_id(session))
    return Home.render_shell(ctx)

  post "/ui/auth/login" body LoginInput -> Html!Unauthorized:
    let session = login_user(body) ?!
    let token = session_token(session)
    response.cookie("sid", token)
    let ctx = session_context(token, session_user_id(session))
    return Home.render_shell(ctx)

  delete "/ui/auth/logout" -> Html:
    let token = request_session_token()
    if token != "":
      transaction:
        db.exec("delete from sessions where token = ?", [token])
    response.delete_cookie("sid")
    return Home.render_shell(anonymous_context())

  get "/ui/public/notes" -> Html:
    let ctx = request_context_or_anonymous()
    return NotesUi.render_public_notes_inner(ctx)

  post "/ui/notes" body NoteCreate -> Html!Unauthorized!Forbidden!BadRequest:
    let ctx = scoped_request_context("notes:write") ?!
    let id = new_note_id() ?!
    transaction:
      db.exec(
        "insert into notes (id, owner_id, title, content, is_public) values (?, ?, ?, ?, '0')",
        [id.value, request_context_user_id(ctx), body.title, body.content]
      )
    return Home.render_shell(ctx)

  put "/ui/notes/{id: String}" body NoteCreate -> Html!NotFound!Unauthorized!Forbidden!BadRequest:
    let ctx = scoped_request_context("notes:write") ?!
    transaction:
      db
        .from("notes")
        .select(["id"])
        .where("owner_id", "=", request_context_user_id(ctx))
        .where("id", "=", id)
        .one()
        ?! NotFound(message="not found")
      db.exec(
        "update notes set title = ?, content = ? where id = ? and owner_id = ?",
        [body.title, body.content, id, request_context_user_id(ctx)]
      )
    return Home.render_shell(ctx)

  put "/ui/notes/{id: String}/visibility" body NoteVisibilityUpdate -> Html!NotFound!Unauthorized!Forbidden!BadRequest:
    let ctx = scoped_request_context("notes:write") ?!
    var is_public = "0"
    if body.published == "1":
      is_public = "1"
    else: 
      if body.published != "0":
        null ?! BadRequest(message="published must be '1' or '0'")
    transaction:
      db
        .from("notes")
        .select(["id"])
        .where("owner_id", "=", request_context_user_id(ctx))
        .where("id", "=", id)
        .one()
        ?! NotFound(message="not found")
      db.exec(
        "update notes set is_public = ? where id = ? and owner_id = ?",
        [is_public, id, request_context_user_id(ctx)]
      )
    return Home.render_shell(ctx)

  delete "/ui/notes/{id: String}" -> Html!Unauthorized!Forbidden:
    let ctx = scoped_request_context("notes:write") ?!
    transaction:
      db.exec("delete from notes where id = ? and owner_id = ?", [id, request_context_user_id(ctx)])
    return Home.render_shell(ctx)

  post "/ui/public/notes/{id: String}/likes" -> Html!NotFound!Unauthorized!Forbidden:
    let ctx = scoped_request_context("notes:read") ?!
    transaction:
      let note = db
        .from("notes")
        .select(["owner_id"])
        .where("is_public", "=", "1")
        .where("id", "=", id)
        .one()
        ?! NotFound(message="not found")
      if note["owner_id"] == request_context_user_id(ctx):
        null ?! Forbidden(message="cannot like your own note")
      db.exec(
        "insert or ignore into note_likes (note_id, user_id) values (?, ?)",
        [id, request_context_user_id(ctx)]
      )
    return Home.render_shell(ctx)
